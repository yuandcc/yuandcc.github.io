<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='c&#43;&#43; 面向对象 Part1 Part1 1. 基础 class的两个经典分类 Class without pointer member(s) Class with pointer member(s) C&#43;&#43; programs 代码的基本形式 .h (类的声明) &#43; .cpp (类的定义) &#43; .h (STL标准库) 2. 头文件 头文件：防卫式声明(常数定义) 内联函数 在头文件声明类的时候即定义在类中 在类外定义的时候使用inline关键字 最后需要看编译器 3. 构造函数 构造函数：与类同名，没有返回类型，有默认构造函数。 构造函数初始化列表 一个变量的值的设定有两个阶段，一个是初始化，一个是赋值。 构造函数初始化列表是在初始化阶段，在函数体内是放弃初始化阶段，通过赋值方式设值。 不可能在程序里面直接调用构造函数，没有这种语法。只能创建对象，构造函数自动被调用。 不带指针的类多数不用写析构函数。 函数重载，为什么可以有多个同名的函数：函数签名不同（实际名称）。多发生在构造函数上。 当有一个有默认值的构造函数时，再声明一个不带参数的构造函数（但是会使用默认值初始化成员变量），会发生错误(编译器不知道调用哪一个)。（构造函数1和2） 构造函数声明为private，不允许外界创建，如单例模式。 4. const修饰符 常量成员函数：const。设计函数的时候就已经明确内部会不会修改成员变量 const 加在变量前表示该变量不可以被修改。 如果调用者使用const修饰的变量(变量还是对象？)调用非const的方法，会发生编译错误。（非const方法不保证不会修改变量） 5. 参数及返回值传递 参数传递 pass by value：传递整个对象数据（可能会很大），传递的动作就是把整个对象压到函数的栈中，尽量不使用. pass by reference （to const）：引用底层就是指针，传引用相当于传指针那么快。能传引用尽量传引用（参数是一个字节的情况）。使用const修饰方法参数，表示内部不能修改。 返回值传递 pass by value pass by reference 在允许的情况下尽量通过reference进行传递。 什么情况允许，什么情况不允许 什么时候返回值可以以引用的形式传递 当返回的是以引用或指针传进来的对象时可以 当返回的是临时变量时不可以，函数调用结束临时变量即销毁 6.'>
<title></title>

<link rel='canonical' href='https://example.com/posts/notes/notes/%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3/c&#43;&#43;/c&#43;&#43;%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_part1/'>

<link rel="stylesheet" href="/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css"><meta property='og:title' content=''>
<meta property='og:description' content='c&#43;&#43; 面向对象 Part1 Part1 1. 基础 class的两个经典分类 Class without pointer member(s) Class with pointer member(s) C&#43;&#43; programs 代码的基本形式 .h (类的声明) &#43; .cpp (类的定义) &#43; .h (STL标准库) 2. 头文件 头文件：防卫式声明(常数定义) 内联函数 在头文件声明类的时候即定义在类中 在类外定义的时候使用inline关键字 最后需要看编译器 3. 构造函数 构造函数：与类同名，没有返回类型，有默认构造函数。 构造函数初始化列表 一个变量的值的设定有两个阶段，一个是初始化，一个是赋值。 构造函数初始化列表是在初始化阶段，在函数体内是放弃初始化阶段，通过赋值方式设值。 不可能在程序里面直接调用构造函数，没有这种语法。只能创建对象，构造函数自动被调用。 不带指针的类多数不用写析构函数。 函数重载，为什么可以有多个同名的函数：函数签名不同（实际名称）。多发生在构造函数上。 当有一个有默认值的构造函数时，再声明一个不带参数的构造函数（但是会使用默认值初始化成员变量），会发生错误(编译器不知道调用哪一个)。（构造函数1和2） 构造函数声明为private，不允许外界创建，如单例模式。 4. const修饰符 常量成员函数：const。设计函数的时候就已经明确内部会不会修改成员变量 const 加在变量前表示该变量不可以被修改。 如果调用者使用const修饰的变量(变量还是对象？)调用非const的方法，会发生编译错误。（非const方法不保证不会修改变量） 5. 参数及返回值传递 参数传递 pass by value：传递整个对象数据（可能会很大），传递的动作就是把整个对象压到函数的栈中，尽量不使用. pass by reference （to const）：引用底层就是指针，传引用相当于传指针那么快。能传引用尽量传引用（参数是一个字节的情况）。使用const修饰方法参数，表示内部不能修改。 返回值传递 pass by value pass by reference 在允许的情况下尽量通过reference进行传递。 什么情况允许，什么情况不允许 什么时候返回值可以以引用的形式传递 当返回的是以引用或指针传进来的对象时可以 当返回的是临时变量时不可以，函数调用结束临时变量即销毁 6.'>
<meta property='og:url' content='https://example.com/posts/notes/notes/%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3/c&#43;&#43;/c&#43;&#43;%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_part1/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' />
<meta name="twitter:title" content="">
<meta name="twitter:description" content="c&#43;&#43; 面向对象 Part1 Part1 1. 基础 class的两个经典分类 Class without pointer member(s) Class with pointer member(s) C&#43;&#43; programs 代码的基本形式 .h (类的声明) &#43; .cpp (类的定义) &#43; .h (STL标准库) 2. 头文件 头文件：防卫式声明(常数定义) 内联函数 在头文件声明类的时候即定义在类中 在类外定义的时候使用inline关键字 最后需要看编译器 3. 构造函数 构造函数：与类同名，没有返回类型，有默认构造函数。 构造函数初始化列表 一个变量的值的设定有两个阶段，一个是初始化，一个是赋值。 构造函数初始化列表是在初始化阶段，在函数体内是放弃初始化阶段，通过赋值方式设值。 不可能在程序里面直接调用构造函数，没有这种语法。只能创建对象，构造函数自动被调用。 不带指针的类多数不用写析构函数。 函数重载，为什么可以有多个同名的函数：函数签名不同（实际名称）。多发生在构造函数上。 当有一个有默认值的构造函数时，再声明一个不带参数的构造函数（但是会使用默认值初始化成员变量），会发生错误(编译器不知道调用哪一个)。（构造函数1和2） 构造函数声明为private，不允许外界创建，如单例模式。 4. const修饰符 常量成员函数：const。设计函数的时候就已经明确内部会不会修改成员变量 const 加在变量前表示该变量不可以被修改。 如果调用者使用const修饰的变量(变量还是对象？)调用非const的方法，会发生编译错误。（非const方法不保证不会修改变量） 5. 参数及返回值传递 参数传递 pass by value：传递整个对象数据（可能会很大），传递的动作就是把整个对象压到函数的栈中，尽量不使用. pass by reference （to const）：引用底层就是指针，传引用相当于传指针那么快。能传引用尽量传引用（参数是一个字节的情况）。使用const修饰方法参数，表示内部不能修改。 返回值传递 pass by value pass by reference 在允许的情况下尽量通过reference进行传递。 什么情况允许，什么情况不允许 什么时候返回值可以以引用的形式传递 当返回的是以引用或指针传进来的对象时可以 当返回的是临时变量时不可以，函数调用结束临时变量即销毁 6.">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu96562699e39615d69773a33be182f3b8_626548_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Example Site</a></h1>
            <h2 class="site-description">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
                <li id="i18n-switch">  
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                    <select name="language" onchange="window.location.href = this.selectedOptions[0].value">
                        
                            <option value="https://example.com/" selected>English</option>
                        
                            <option value="https://example.com/zh-cn/" >中文</option>
                        
                            <option value="https://example.com/ar/" >عربي</option>
                        
                    </select>
                </li>
            
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>Dark Mode</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#part1">Part1</a>
      <ol>
        <li><a href="#1-基础">1. 基础</a></li>
        <li><a href="#2-头文件">2. 头文件</a></li>
        <li><a href="#3-构造函数">3. 构造函数</a></li>
        <li><a href="#4-const修饰符">4. const修饰符</a></li>
        <li><a href="#5-参数及返回值传递">5. 参数及返回值传递</a></li>
        <li><a href="#6-友元">6. 友元</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/notes/notes/%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3/c&#43;&#43;/c&#43;&#43;%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_part1/"></a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    3 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="c-面向对象-part1">c++ 面向对象 Part1</h1>
<h2 id="part1">Part1</h2>
<h3 id="1-基础">1. 基础</h3>
<ol>
<li>class的两个经典分类
<ul>
<li>Class without pointer member(s)</li>
<li>Class with pointer member(s)</li>
</ul>
</li>
<li>C++ programs 代码的基本形式
.h (类的声明) + .cpp (类的定义) + .h (STL标准库)</li>
</ol>
<h3 id="2-头文件">2. 头文件</h3>
<ol>
<li>头文件：防卫式声明(常数定义)</li>
<li>内联函数
<ol>
<li>在头文件声明类的时候即定义在类中</li>
<li>在类外定义的时候使用inline关键字</li>
<li>最后需要看编译器</li>
</ol>
</li>
</ol>
<h3 id="3-构造函数">3. 构造函数</h3>
<ol>
<li>构造函数：与类同名，没有返回类型，有默认构造函数。</li>
<li>构造函数初始化列表
<ol>
<li>一个变量的值的设定有两个阶段，一个是初始化，一个是赋值。</li>
<li>构造函数初始化列表是在初始化阶段，在函数体内是放弃初始化阶段，通过赋值方式设值。</li>
</ol>
</li>
<li>不可能在程序里面直接调用构造函数，没有这种语法。只能创建对象，构造函数自动被调用。</li>
<li>不带指针的类多数不用写析构函数。</li>
<li>函数重载，为什么可以有多个同名的函数：函数签名不同（实际名称）。多发生在构造函数上。</li>
<li>当有一个有默认值的构造函数时，再声明一个不带参数的构造函数（但是会使用默认值初始化成员变量），会发生错误(编译器不知道调用哪一个)。（构造函数1和2）</li>
<li>构造函数声明为private，不允许外界创建，如单例模式。</li>
</ol>
<h3 id="4-const修饰符">4. const修饰符</h3>
<ol>
<li>常量成员函数：const。设计函数的时候就已经明确内部会不会修改成员变量
<ol>
<li>const 加在变量前表示该变量不可以被修改。</li>
<li>如果调用者使用const修饰的变量(变量还是对象？)调用非const的方法，会发生编译错误。（非const方法不保证不会修改变量）</li>
</ol>
</li>
</ol>
<h3 id="5-参数及返回值传递">5. 参数及返回值传递</h3>
<ol>
<li>参数传递
<ol>
<li>pass by value：传递整个对象数据（可能会很大），传递的动作就是把整个对象压到函数的栈中，尽量不使用.</li>
<li>pass by reference （to const）：引用底层就是指针，传引用相当于传指针那么快。能传引用尽量传引用（参数是一个字节的情况）。使用const修饰方法参数，表示内部不能修改。</li>
</ol>
</li>
<li>返回值传递
<ol>
<li>pass by value</li>
<li>pass by reference</li>
<li>在允许的情况下尽量通过reference进行传递。</li>
<li>什么情况允许，什么情况不允许</li>
</ol>
</li>
<li>什么时候返回值可以以引用的形式传递
<ol>
<li>当返回的是以引用或指针传进来的对象时可以</li>
<li>当返回的是临时变量时不可以，函数调用结束临时变量即销毁</li>
</ol>
</li>
</ol>
<h3 id="6-友元">6. 友元</h3>
<ol>
<li>
<p>友元</p>
<ol>
<li>在类中声明的友元函数或者友元类可以通过该类的对象访问该类的私有变量</li>
<li>友元破坏了数据的封装性，除友元外还可以使用函数来获取私有变量</li>
<li>相同class的各个object互为friends（友元）</li>
</ol>
</li>
<li>
<p>class body 外的各种定义</p>
<ol>
<li>数据是不是声明为private</li>
<li>参数尽可能以reference来传，尽可能声明为const</li>
<li>返回值尽可能以reference来传</li>
<li>该加const的地方需要加上const(成员函数，成员变量，参数)</li>
<li>构造函数使用成员初始化列表</li>
</ol>
</li>
<li>
<p>操作符重载</p>
<ol>
<li>在c++中操作符就是一种函数，可以被重新定义</li>
<li>操作符重载1-成员函数 带this指针
<ol>
<li>所有的二元操作符（左右两个操作数的），作用在左面对象上。this即为左面对象的指针，调用左面对象的成员方法。</li>
<li>每个成员函数都隐藏一个this指针，指向调用该对象的对象的指针。</li>
<li>this不能写在参数列，否则会报错。但是在成员函数体内可以使用this指针。</li>
<li>+=：assignment plus</li>
</ol>
</li>
<li>return by reference 分析
<ol>
<li>以reference来接收，传递者无需知道接收者是以reference形式接收。无论是否以引用形式接收，传递者传object即可。</li>
<li>如果是以pointer来接收，传递者则需要加取址符号。</li>
<li>+= 操作符的返回值不可以是void类型。
<ol>
<li>若是void， 仅c2 += c1可以。</li>
<li>若是reference，c3 += c2 += c1也可以。</li>
</ol>
</li>
</ol>
</li>
<li>操作符重载2-非成员函数 无this指针
<ol>
<li>全域函数，没有this指针</li>
<li>对于+操作符，返回值必定是local temp object（临时对象），返回值不能以reference来传递</li>
<li>对于+操作符，设计为全局函数，因为可以复数+实属，也可以实数加复数。如果设计为成员函数，可以实现的加法类型就受限了。</li>
<li>typename() 来创建临时对象，没有名字，临时对象的生命周期只有一行，下一行生命就会终止。</li>
<li>取反操作符-，与相减操作符-，符号相同，参数个数不同，以此实现重载。</li>
<li>&laquo; 重载
<ol>
<li>对于一些操作符重载，可以重载为成员函数或非成员函数</li>
<li>对于&laquo;等特殊的操作符，只能重载为非成员函数。如果重载为成员函数，操作符只能作用在左面的对象身上，则只能这样用：c1 &laquo; cout;</li>
<li>cout 是一种ostream的类型</li>
<li>第一个参数是ostream参数，可以是引用，但不能是const, 因为输出流一直会改变。第二个参数是要输出的对象。</li>
<li>返回类型值：为了使用者连续输出，返回值类型是ostream类型的引用。若只输出一次，则只能输出一次。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>访问私有变量的两个方法</p>
<ol>
<li>成员函数</li>
<li>友元</li>
</ol>
</li>
<li>
<p>理论上可以在任意地方include，除了函数内部。</p>
</li>
</ol>
<p>class with pointer members
拷贝构造和拷贝赋值：
每个类如果不写的话有默认的拷贝构造和拷贝赋值函数
拷贝构造和拷贝赋值函数底层是一个bit一个bit的进行拷贝
当类中带有指针成员变量时，一定不能用默认的拷贝构造和拷贝赋值函数
string 类的设计
使用char类型的成员指针变量，以此适应不同长度的字符串。
三个特殊的函数
拷贝构造函数，与类同名，无返回值，形参为该类的对象，const to referen类型。
拷贝赋值函数，赋值操作符的操作符重载函数，返回值为该类类型的引用，形参为该类的对象，const to referen类型。
析构函数，对象生命周期结束时调用，释放动态分配给指针的内存。
当类中带指针时，必须手动声明并定义这三个特殊函数（或者拷贝构造和拷贝赋值？）。 <br>
字符串多长？
c/c++：字符串后面有结束符号，c++字符串的长度等字符串长度+1
Pascal：前面有长度部分
当类带有指针成员变量时，如果不重写拷贝构造函数和拷贝赋值函数，会有以下危险：
b = a 进行复制后，原来b对象中指针指向的内存区域发生内存泄漏。
a和b对象的指针指向同一片内存（浅拷贝），可能存在危险。
string类的拷贝构造函数
在拷贝构造函数中直接通过传进来的string类型的对象来直接访问私有变量，同一类型的不同对象互为友元。</p>
<ol>
<li>
<p>根据传进来的string对象中保存的字符串的长度创建空间，2) 将指针指向的内容拷贝到新创建的空间中。
string类的拷贝赋值函数
检测是否是自我赋值（通过this指针和传进来的对象的地址比较）
如果不做检查，如果遇到自我赋值会有以下危险：
进行多余的不必要动作，效率低
会首先把指针指向的空间释放掉（唯一的空间），会发生错误
1）释放已分配的空间，  2）根据传进来的string对象中保存的字符串的长度创建空间，3) 将指针指向的内容拷贝到新创建的空间中。
返回this指针的取值（为了可以连续的赋值，否则可以不返回），返回类型是该类的引用。
string类重载&laquo;运算符
同复数类。
cout可以直接接收char类型指针进行输出。
char * 指向字符串为c风格的字符串。
strlen（char *）是字符串不包括结束符号的真实长度。
关于inline，对于复杂的函数，加上inline也没关系，没有副作用，编译器会视情况决定是否去实现。
&amp;出现在typename的后面表示是该类型的引用（如在形参中使用），放在object前面，表示是取该对象的地址，如传递给指针时需要取对象的地址。</p>
<p>堆/栈与内存管理
栈
存在于某作用域的一块内存空间。
如函数调用，会产生一个栈空间来存放函数所接收的参数，临时变量（函数内声明的任何变量）及返回地址。
作用域可以是某个函数内吗，也可以是大括号包围的某个代码段。
堆
由操作系统提供的一块全局空间。
程序通过动态分配的方式来获得堆中的空间。
通过new动态分配的空间需要手动释放。
不同类型的对象
stack object的声明在作用域结束之际结束，这种作用域内的object，又称为auto object，因为它会被自动清理。
声明对象时通过static进行修饰, 对象便是static object，其生命周期在作用域结束后仍然存在，直到整个程序结束。（静态对象 ）
全局对象，声明在全局作用域内，可以视为一种静态对象，生命周期为声明到程序结束，作用域是整个程序。
heap object，通过new生成对象指针，通过delete该指针释放内存，delete该指针会调用该对象的析构函数。堆对象的生命周期是声明到被delete之际。通过new声明堆对象后如果不delete会产生内存泄漏。（指针指向的堆对象还存在，但是指针的生命周期结束了，作用域之外再也看不到该指针，也就没有机会delete了。即指针死亡了，但是指针指向得到空间还在。）
new内部机制
new底层包含三个动作（编译器的实现）：1）分配内存 2）转型 3）调用构造函数
分配内存：
通过c++提供的operator new方法来分配内存，内部调用底层的malloc方法。（只有成员变量需要占空间，如复数类两个double类型的变量，此处就是8个字节）。
将void类型的内存转为实际类型（即该实际类型的指针）。
通过转型后的指针调用构造函数，该指针也作为参数传给构造函数的this指针。
delete内部机制
delete底层包含两个动作（编译器实现）：1）调用析构函数 2）释放内存
调用析构函数：释放通过new动态分配的堆上的内存。
调用c++提供的operator delete释放该对象本身所占用的内存（对于string类的对象来说，就是一个成员指针变量）。内部调用free方法。
动态分配所得的内存。
内存块大小分析：对象本身大小 + 调试模式（调试模式下会在对象位置前后分别占用32（debugger header）和4个字节（no man land），非调试模式没有该部分（release mode））+ 内存前后的cookie（4<em>2个字节） + 16字节倍数对齐需要的padding
cookie记录整个分配内存的大小，方便内存回收。（因为回收时只有一个指针，并不知道大小）
cookie的最后一位是1，以此标志此块内存分配出去了（即程序获得了该块内存），0表示没有分配出去，即可以用来分配（释放内存，还给操作系统后，最后1位变成0）。因为16字节对齐的话，即是16字节倍数的话，申请内存的大小以二进制表示的话最后四个bit一定是0，因此借用最后一位来标记。
在32位机器上，一个指针大小为4个字节。
动态分配数组内存
new搭配delete，array new要搭配array delete。
内存块大小分析：对象本身大小</em>个数（数组的长度）+ 调式模式（32 +4 给字节，如果开启调试模式的话）+ 该段内存前后cookie（4*2个字节）+ 数组长度（即保存的对象个数，1个字节）+ 16字节对齐需要的padding
使用array delete释放内存时，编译器知道是个数组，含有多个对象，会调用多次析构函数，析构函数会把各自分配的动态内存删掉。若使用delete释放时，编译器以为只有一个对象，只会调用一次析构函数。剩下的析构函数不会被调用，动态分配的内存不会被收回。内存泄漏的是动态分配的内存，上面分析大小的那段内存会在调用完析构函数后收回。
像复数这种不含指针的类，使用array new后不使用array delete也不会发生内存泄漏。但是良好的习惯是搭配array delete使用。</p>
</li>
</ol>
<p>补充：
static
如何使用static？在成员变量或成员方法声明时加上static修饰，就成为了静态成员变量或静态成员方法。
成员方法只有一份，对于不同的对象调用相同的成员方法，其实是传进去的this指针不同，然后根据不同的this指针找到不同的数据进行处理。
this指针，成员方法里面可写可不写，但是参数中一定不能写，是编译器自动加进去的。
静态数据只有一份，在内存中与对象是分开存放的。
静态函数没有this指针，静态函数只能处理静态数据。
声明和定义：当语句导致获得内存，该行语句便叫做定义。
当类中声明了静态数据时，需要单独在类外对该变量进行定义：类型 类名：：变量名= 初值（赋初值不是必须的）。
调用静态方法的两种方式：
通过对象调用。但是不同于非静态方法的调用，编译器不会把当前对象的地址传给方法的this指针。
通过类名调用。
在方法内部定义static对象或变量，只有当该方法被第一次调用时，该静态对象才会生成，方法调用结束后，该静态对象仍然存在，下一次调用该方法不会再次创建该静态对象（永远只有一份）。
单例模式：
把构造函数放到private里，不允许外部调用
提供静态方法，在方法内部创建静态对象并将该对象方法。（另外一种做法是在类内单独声明静态对象，不在方法中定义。）
通过调用静态方法拿到静态对象，调用相应的方法。
cout可以打印各种类型
extern 关键字声明cout
cout的类继承自ostream，ostream针对各种类型实现了&laquo;操作符重载。
模板类
声明类的时候，最开始使用 templa<!-- raw HTML omitted -->，内部用T表示类型。
使用的时候，声明对象的时候通过&lt;&gt;说明实际类型。
模板会造成代码的膨胀(不是缺点)
模板函数
声明、定义方法的时候，最开始使用 templa<!-- raw HTML omitted -->，内部用T表示类型。
使用的时候无需像模板类那样额外声明，编译器会对模板函数进行参数类型推导。
传进的参数类型需要支持模板函数内部的操作（可能需要该类实现操作符重载）
namespace
语法：namespce std { }。
防止和其他的程序出现同名导致冲突。
同一个命名空间的代码不一定写到一起，可以分开写，都用同样的命名空间包住。
使用命名空间下的东西：
using directive：using namespace std；
using declaration：using std::cout;
直接使用：std::cout &laquo; std::endl;
组合与继承
类之间的三种关系：继承，复合，委托
Composition：复合，表示has-a的关系。画图表示：黑色菱形表示复合。
Container类中拥有Component对象作为成员变量。
设计模式：Adapter。A拥有B，A的功能由调用B实现。A为了需求改下名称或者接口。A为adapter。
内存（对象大小）角度分析：A的大小包含B。
构造和析构（代码中红色部分为编译器自动加上的）
构造由内而外，A的构造函数首先调用B的默认构造函数。
A::A(&hellip;): B() {&hellip;};
析构由外而内，A首先执行自己的构造函数，然后调用B的构造函数。
A::~A(&hellip;) {&hellip; ~B()};
在A调用B的构造函数时，调用的是其默认构造函数。如需调用B的其他构造函数进行初始化，需要手动调用（在A的初始化列表中调用B对应的构造函数）。
Delegation：委托，Composition by reference。画图表示，空心菱形表示委托。
A中拥有B的指针作为成员变量。
Composition by reference。学术界中没有by pointer，只有by value和by reference。即使在传指针，依然称为by reference。
A和B的生命周期不同步。A先创建出来，因为拥有的是B的指针，可以等到需要B的时候再创建B。
设计模式：Handle/Body(pImpl): 由指针指向实现所有功能的类B，A的功能通过调用成员变量B指针来实现。A是Handle，B是Body。
A可以不变，B可以指向不同的实现类，不会外部对接口的使用。
又称编译防火墙，A不用再编译，只需要编译B即可。
用在string类，可以做reference counting。
B中包含计数变量和一个真正字符串（char <em>）。
copy on write：针对共享，需要修改时，先拷贝一个副本，在副本上进行修改。
当类中带有指针时，需要注意的三个函数：
拷贝构造
拷贝赋值
析构函数
Inheritance：继承。表示is-a的关系。画图表示，用空心三角形表示继承。
继承语法，关键字。
内存角度（对象大小）：子类的对象具有父类的成分。
继承最有价值的部分，与虚函数搭配。
构造和析构（B基类，A派生类）：
构造由内而外（编译器实现）。
首先调用基类的默认构造函数，再调用派生类的构造函数。
A::A(&hellip;): B() {&hellip;};
析构由外而内（编译器实现）。
首先调用派生类的析构函数，再调用基类的析构函数。
A::~A(&hellip;) {&hellip; ~B()};
基类的析构函数必须是virtual，否则会出现undefined behavior。
继承与虚函数
三种成员函数
非虚函数：不希望子类去重新定义（override，覆写）它。覆写只用在子类重新定义父类成员函数的情况。
虚函数：希望子类重新定义，且父类已经有了默认的定义。关键字：virtual。
纯虚函数：希望子类一定要提供函数的定义，父类没有默认的定义（其实纯虚函数可以有定义），否则不会通过编译。virtual func() = 0。
纯虚函数不等同于空函数，空函数可以通过编译。
虚函数运行分析：
通过子类对象调用父类的函数。
设计模式：Template Method：在父类成员方法的定义中，把暂时无法确定的动作抽象成函数，交由子类去定义。
子类对象调用父类的方法，子类对象的地址会被作为this指针传进去。
BaseClass::Func(&amp;obj)
父类方法内在调用其他方法时是通过this来进行调用。
this-&gt;Func();
(</em>(this-&gt;vptr)[n])(this);
Inheritance + Composition情况下的构造和析构
子类具有Component。
子类对象包含基类部分和Component部分。
基类的构造函数和Component的构造函数的调用顺序影响不大，但是需要去明确具体顺序（构造函数打印cout，观察一下）。最后执行子类的构造函数。
父类具有Component。
子类对象包含基类部分，基类部分包含Component部分。
构造函数调用：子类构造时先调用基类构造函数，基类构造时先调用Component构造函数。所以顺序是：Component，基类，子类。
析构函数与构造函数相反。
Delegation + Inheritance
Observer设计模型
数据类拥有一个Observer类指针数组（此处必须要是指针，因为c++ vector中的元素必须一样大小，如果直接放对象不能保证一样大小）。（委托）
Observer作为基类可以被继承，有不同实现。（继承）
一个数据类可以被不同类型的observer访问。当数据修改时，不同的observer可以被同时感知到，以触发相应的行为（如数据展示）。
数据类中需要提供几个功能函数：
注册，将observer放入到Observer类指针数组中。
注销。
notify，通知：遍历调用observer相应接口，更新数据。（需要observer提供接口）
委托相关设计
设计模式：对于一类问题的一种解法。
设计模式：Composite。
文件系统设计：文件夹和文件，文件夹里可以放文件夹和文件。
文件：Primitive类
文件夹：Composite类
Primitive类和Composite类均继承自Component类。（继承）
Component设计：
int类型成员变量
add成员方法，参数为Component类型指针（可以往文件夹里面add文件和文件夹，所以是父类的指针），且为虚函数，无动作（不能为纯虚函数，文件类不需要实现）。
Primitive类设计：
简单继承Component类
不覆写add方法。
Composite类设计：
vector成员变量，元素类型为Component指针(不能为对象, 对象类型、大小不一致)，表示文件夹里面的文件和文件夹。
覆写add方法。
设计模式：Prototype。
问题：有一个继承体系，在父类中需要创建未来才出现的子类类型的对象。（当前不知道未来的子类名称）即现在要去创建未来的类的对象。
解法：未来的子类创建自己的对象给父类。
画图表示，下划线静态类型。-表示私有，#表示protect。
类的设计：
基类 Image：
static Image *findAndClone(imageType); public方法，通过类型找到对应子类的原型（对象）并拷贝一个对象副本返回。
virtual Image *clone() = 0; 纯虚函数，子类必须实现，父类在findAndClone方法中通过子类原型对象调用，已得到对应副本。（静态函数调用需要类名，clone不能设计为静态类型函数。clone函数的设计，需要知道对应的类型，所以只能通过对象调用）。
static void addPrototype(Image *image)；子类在默认构造函数中调用，以将原型对象注册到基类中。
static Image *_prototypes[10]; Image指针类型的数组，用来存放，子类注册的原型对象指针。
子类LandSatImage：
public 方法：Image *clone()；内部通过调用子类的非默认构造函数（防止和原型对象重复）生成副本对象并返回。
LandSatImage(int dummy)；带参数的构造函数，保护或私有类型。在clone函数中被调用，用来生成副本对象(区分原型和副本)。构造函数内部会将成员变量_id加一。
static LandSatImage _landSatImage; 私有变量，子类类型的静态变量。在程序开始时会调用子类的默认构造函数，并在默认构造函数中将该类型原型注册到父类中。注意静态变量调用构造函数的时间。
LandSatImage()；默认构造函数，私有变量。静态成员变量_landSatImage初始化时调用，在构造函数中调用addPrototype(this); 通过this指针将该类原型注册到基类中。
static int _count; 记录当前类型副本的个数。
int _id; 当前类型对象的id。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 Example Site
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
